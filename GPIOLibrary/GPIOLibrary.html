<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GPIO C Library - Advanced Computer Engineering</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item "><a href="../Introduction/Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Debian Rock C4</li><li class="chapter-item "><a href="../Debian_Rock/Debian_Rock.html"><strong aria-hidden="true">2.</strong> Debian Rock C4</a></li><li class="chapter-item "><a href="../tmux/tmux.html"><strong aria-hidden="true">3.</strong> Terminal Multiplexing</a></li><li class="chapter-item "><a href="../vim/vim.html"><strong aria-hidden="true">4.</strong> vim</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> Fork Bomb</div></li><li class="chapter-item "><div><strong aria-hidden="true">6.</strong> Multi-Threading 1</div></li><li class="chapter-item "><div><strong aria-hidden="true">7.</strong> Multi-Threading 2</div></li><li class="chapter-item "><div><strong aria-hidden="true">8.</strong> System Calls</div></li><li class="chapter-item "><div><strong aria-hidden="true">9.</strong> Daemons</div></li><li class="chapter-item "><div><strong aria-hidden="true">10.</strong> UUID</div></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">BeagleBoard</li><li class="chapter-item "><a href="../ChipExploration/ChipExploration.html"><strong aria-hidden="true">11.</strong> Exploring the Chips</a></li><li class="chapter-item "><a href="../PinExploration/PinExploration.html"><strong aria-hidden="true">12.</strong> PinExploration</a></li><li class="chapter-item expanded "><a href="../GPIOLibrary/GPIOLibrary.html" class="active"><strong aria-hidden="true">13.</strong> GPIO C Library</a></li><li class="chapter-item "><a href="../ADCLibrary/ADCLibrary.html"><strong aria-hidden="true">14.</strong> ADC C Library</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ADCLibrary/ADCContinous.html"><strong aria-hidden="true">14.1.</strong> ADC Continous </a></li></ol></li><li class="chapter-item "><a href="../PWMLibrary/PWMLibrary.html"><strong aria-hidden="true">15.</strong> PWM C Library</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../PWMLibrary/ADCtoPWM.html"><strong aria-hidden="true">15.1.</strong> ADC to PWM Library</a></li></ol></li><li class="chapter-item "><a href="../Libioctrl/Libioctrl.html"><strong aria-hidden="true">16.</strong> libioctrl</a></li><li class="chapter-item "><div><strong aria-hidden="true">17.</strong> USB Ethernet</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">17.1.</strong> USB to Ethernet sniffing tool</div></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">18.</strong> Mounting an SD</div></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">C</li><li class="chapter-item "><div><strong aria-hidden="true">19.</strong> Learning C</div></li><li class="chapter-item "><div><strong aria-hidden="true">20.</strong> Embedded C</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">20.1.</strong> atmega328p</div></li><li class="chapter-item "><div><strong aria-hidden="true">20.2.</strong> avr-gcc</div></li><li class="chapter-item "><div><strong aria-hidden="true">20.3.</strong> Blink</div></li><li class="chapter-item "><div><strong aria-hidden="true">20.4.</strong> UART</div></li><li class="chapter-item "><div><strong aria-hidden="true">20.5.</strong> ADC</div></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Rust</li><li class="chapter-item "><div><strong aria-hidden="true">21.</strong> Intro to Rust</div></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Bourne Again SHell</li><li class="chapter-item "><a href="../Redirection/Redirection.html"><strong aria-hidden="true">22.</strong> Redirection</a></li><li class="chapter-item "><a href="../Bash/Bash_Scripting.html"><strong aria-hidden="true">23.</strong> Bash</a></li><li class="chapter-item "><a href="../ManPages/ManPages.html"><strong aria-hidden="true">24.</strong> Man Pages</a></li><li class="chapter-item "><a href="../SystemsStats/SystemsStats.html"><strong aria-hidden="true">25.</strong> Systems Stats Script</a></li><li class="chapter-item "><a href="../RFC_Logger/rfclogger.html"><strong aria-hidden="true">26.</strong> RFC Logger</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Git</li><li class="chapter-item "><a href="../myFirstRepository/myFirstRepository.html"><strong aria-hidden="true">27.</strong> My First Repository</a></li><li class="chapter-item "><a href="../BranchingModel/BranchingModel.html"><strong aria-hidden="true">28.</strong> Branching-Strategy</a></li><li class="chapter-item "><a href="../OneFlow/OneFlow.html"><strong aria-hidden="true">29.</strong> Git Oneflow</a></li><li class="chapter-item "><a href="../AntiPatterns/AntiPatterns.html"><strong aria-hidden="true">30.</strong> Anti Patterns</a></li><li class="chapter-item "><a href="../ContinousDeployment/ContinousDeployment.html"><strong aria-hidden="true">31.</strong> Continous Deployment</a></li><li class="chapter-item "><a href="../ReleaseDeployment/ReleaseDeployment.html"><strong aria-hidden="true">32.</strong> Release Deployment</a></li><li class="chapter-item "><a href="../Migration/Migration.html"><strong aria-hidden="true">33.</strong> Migration</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advanced Computer Engineering</h1>

                    <div class="right-buttons">

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gpio-library-creation-and-system-wide-installation-guide"><a class="header" href="#gpio-library-creation-and-system-wide-installation-guide">GPIO Library Creation and System-Wide Installation Guide</a></h1>
<p>This workshop will detail how to set up the BBB’s GPIO pins. General Purpose Input/Output (GPIO) pins are special in that they can be configured at runtime to perform in a variety of ways, ranging from simple i/o to serial interfaces to specialized encoder readings. While the BBB supports up the 69 gpio pins, in reality the majority of the pins are being used by onboard system processes such as the board’s HDMI and LCD abilities. This post will detail the steps necessary to take advantage of these otherwise inaccessible pins, as well as configure a gpio pin to suit the user’s needs.</p>
<p>This guide walks you through creating a simple GPIO library in C, compiling it into both a static and shared library, and installing it system-wide. We'll start with manual <code>gcc</code> commands and then automate the process using a <code>Makefile</code>.</p>
<h2 id="linux-kernel-version"><a class="header" href="#linux-kernel-version">Linux Kernel Version</a></h2>
<p>This guide assumes the user’s BBB is running Linux Kernel 4.1.15. If an earlier version is used, such as 3.8.X, then abundant information on configuring the BBB can be found through google and the procedures listed in this guide will probably not work.</p>
<h2 id="bbb-headers-and-pinout"><a class="header" href="#bbb-headers-and-pinout">BBB Headers and Pinout</a></h2>
<p>The BBB has two 23 pin columns on each side of the board, for a total of 92 pins available to the user. The right header is designated as P8 while the left is designated P9. Pay careful attention to the orientation of the BBB in reference to the pinout numbers, else you risk mis-wiring the board and potentially causing irreversible damage. Physical pins are numbered in the following manner, <strong>PX_Y</strong>, where <strong>X</strong> is the header where the pin is located (8 or 9) and <strong>Y</strong> is the location of the pin with that header. Pins <code>P8_1</code> and <code>P9_1</code> are located at the top right of each header. Notice that the left column of each header are all the odd pins while the right column of each header are all the even pins.</p>
<div align=center>
<p><img src="./figures/bbb_headers.png" alt="" /></p>
</div>
<p>As seen in the graphic, the first and last rows of pins are dedicated to nets such as <strong>DGND</strong>, <strong>VDD_3V3</strong> (3.3V Output), <strong>VDD_5v</strong> (5V Output), and system power/reset. The rest of the pins are configurable in software, as will be detailed later in this post. The labels on the graphic show the default mode of the pins. Not all pins are able to be used as GPIO’s immediately. Systems such as the LCD and HDMI drivers take priority to these pins. A more detailed view of the BBB’s header’s and pin usage can be seen in the graphics below</p>
<p><img src="./figures/P8Header.png" alt="" />
<img src="./figures/P9Header.png" alt="" /></p>
<h3 id="gpio-numbering-scheme"><a class="header" href="#gpio-numbering-scheme">GPIO Numbering Scheme</a></h3>
<p>The gpio pins of the bbb are grouped into 3 groups of 32: <em>GPIO0</em>, <em>GPIO1</em>, and <em>GPIO2</em>. An individual pin can be refered to using the
convention <code>GPIOX_Y</code> where <code>X</code> is its gpio register and <code>Y</code> is its number within that register. <em>However, all references to a particular
pin made in software instead uses its absolute pin number!</em> A gpio's <em>absolute</em> pin number is calculated in the following manner: <code>Z = 32*X + Y</code> where <code>X</code> is again the gpio register and <code>Y</code> is the position within that register.</p>
<p>i.e. GPIO2_24 is <code>32*2+24</code>, making it GPIO_88. <em>If this pin were to be referenced anywhere in software, the user would use the number 88, not 24</em>!</p>
<h3 id="overloaded-pins"><a class="header" href="#overloaded-pins">Overloaded Pins</a></h3>
<p>Additional scrutiny of the above header pin layouts shows all the possible uses of each individual pin. Any pin highlighted in red is a pin that is inaccessible for use as a gpio pin by default, see the notes column for it's initial allocation. As an example, P8_28, aka GPIO2_24, aka GPIO_88, is by default allocated to the <code>nxp_hdmi_bonelt_pins</code> group. While it is overloaded in this capacity,no other use can be made of this pin. Multiple modes are available for each pin, and setting these modes wil be discussed in a later section.</p>
<h3 id="recap-of-numbering-schemes"><a class="header" href="#recap-of-numbering-schemes">Recap of Numbering Schemes</a></h3>
<p>As a recap, <em>each gpio pin on the BBB has three different numbering schemes associated with it!</em></p>
<ol>
<li>The physical pin location, in the form of <code>PX_Y</code> (P8_28)</li>
<li>The gpio name, in the form of <code>GPIOX_Y</code> (GPIO2_24)</li>
<li>The gpio number, in the form of <code>32*X + Y</code> (88)</li>
</ol>
<p>Only the last scheme, the gpio number, is used in software!</p>
<h2 id="interacting-with-gpio-pins-on-the-beaglebone-black-bbb-via-sysfs"><a class="header" href="#interacting-with-gpio-pins-on-the-beaglebone-black-bbb-via-sysfs">Interacting with GPIO Pins on the BeagleBone Black (BBB) via Sysfs</a></h2>
<p>The BeagleBone Black (BBB) and similar Linux-based systems allow you to interact with GPIO (General-Purpose Input/Output) pins using the sysfs interface. This interface exposes GPIO control via a set of files in the <code>/sys/class/gpio</code> directory. Below is an explanation of common GPIO operations using this interface.</p>
<h3 id="1-change-directory-to-gpio-sysfs-interface"><a class="header" href="#1-change-directory-to-gpio-sysfs-interface">1. Change Directory to GPIO Sysfs Interface</a></h3>
<pre><code class="language-bash">$ cd /sys/class/gpio
</code></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<blockquote>
<ul>
<li>The <code>/sys</code> directory is a virtual filesystem (<code>sysfs</code>) that the Linux kernel uses to expose information and configuration options for various devices and drivers.
Within <code>/sys/class/gpio</code>, you'll find files and directories related to the GPIO subsystem, allowing you to interact with GPIO pins directly from the command line or within scripts.</li>
</ul>
</blockquote>
</blockquote>
<p>Elevate user to super user.</p>
<pre><code class="language-bash">$ sudo su
</code></pre>
<p>We interact with BBB pins via a set of files that are read/written to. To reach the directory where these files are located, enter the following.</p>
<pre><code class="language-bash">$ cd /sys/class/gpio
</code></pre>
<p>List the directory.</p>
<pre><code class="language-bash">$ ls -l
--w--w---- 1 root gpio 4.0K Apr  7 20:17 export
lrwxrwxrwx 1 root gpio    0 Apr  7 20:17 gpio10 -&gt; ../../devices/platform/ocp/44e07000.gpio/gpiochip0/gpio/gpio10
lrwxrwxrwx 1 root gpio    0 Apr  7 20:17 gpio11 -&gt; ../../devices/platform/ocp/44e07000.gpio/gpiochip0/gpio/gpio11
lrwxrwxrwx 1 root gpio    0 Apr  7 20:17 gpio110 -&gt; ../../devices/platform/ocp/481ae000.gpio/gpiochip3/gpio/gpio110
lrwxrwxrwx 1 root gpio    0 Apr  7 20:17 gpio111 -&gt; ../../devices/platform/ocp/481ae000.gpio/gpiochip3/gpio/gpio111
lrwxrwxrwx 1 root gpio    0 Apr  7 20:17 gpio112 -&gt; ../../devices/platform/ocp/481ae000.gpio/gpiochip3/gpio/gpio112
...
--w--w---- 1 root gpio 4.0K Apr  7 20:17 unexport
</code></pre>
<pre><code class="language-bash">$ cd gpio27
</code></pre>
<p>If you ls the directory you will see the following:</p>
<pre><code class="language-sh">$ ls
</code></pre>
<h4 id="understanding-files-and-directories-in-the-gpio-directory"><a class="header" href="#understanding-files-and-directories-in-the-gpio-directory">Understanding Files and Directories in the <code>gpio#</code> Directory</a></h4>
<p>When working with GPIO (General-Purpose Input/Output) pins on a BeagleBone Black (BBB) or similar Linux-based systems, you'll encounter several files and directories within the <code>gpio#</code> directory located in <code>/sys/class/gpio/</code>. Each file or directory serves a specific purpose in controlling and configuring the GPIO pin. Here's what each one does:</p>
<p><strong>Files and Directories</strong></p>
<ol>
<li>
<p><code>active_low</code></p>
<ul>
<li><strong>Purpose:</strong> Controls whether the logic level of the GPIO pin is inverted.</li>
<li><strong>Values:</strong>
<ul>
<li><code>0</code>: The default setting. A <code>0</code> in the <code>value</code> file corresponds to a low logic level (0V), and a <code>1</code> corresponds to a high logic level (3.3V or 5V, depending on the board).</li>
<li><code>1</code>: Inverts the logic level. A <code>0</code> in the <code>value</code> file now corresponds to a high logic level, and a <code>1</code> corresponds to a low logic level.</li>
</ul>
</li>
<li><strong>Usage:</strong> Writing <code>1</code> to this file inverts the pin's logic, which can be useful when dealing with hardware that operates on inverted logic.</li>
</ul>
</li>
<li>
<p><code>device</code></p>
<ul>
<li><strong>Purpose:</strong> A symbolic link to the device directory in sysfs that represents the GPIO controller to which this GPIO pin belongs.</li>
<li><strong>Details:</strong> This link provides a path back to the parent device, helping to identify the specific GPIO controller that manages this pin, especially on systems with multiple GPIO controllers.</li>
</ul>
</li>
<li>
<p><code>direction</code></p>
<ul>
<li><strong>Purpose:</strong> Configures the direction of the GPIO pin.</li>
<li><strong>Values:</strong>
<ul>
<li><code>in</code>: Configures the pin as an input, allowing you to read the state of the pin.</li>
<li><code>out</code>: Configures the pin as an output, allowing you to set the state of the pin.</li>
</ul>
</li>
<li><strong>Usage:</strong> You can read or write to this file to change or check whether the GPIO pin is set as an input or output.</li>
</ul>
</li>
<li>
<p><code>edge</code></p>
<ul>
<li><strong>Purpose:</strong> Configures the type of edge detection to trigger an interrupt for the GPIO pin.</li>
<li><strong>Values:</strong>
<ul>
<li><code>none</code>: No edge detection.</li>
<li><code>rising</code>: Detects when the pin changes from low to high.</li>
<li><code>falling</code>: Detects when the pin changes from high to low.</li>
<li><code>both</code>: Detects both rising and falling edges.</li>
</ul>
</li>
<li><strong>Usage:</strong> Writing to this file sets the type of edge detection. It's often used in interrupt-driven applications where you need to respond to changes in the GPIO pin's state.</li>
</ul>
</li>
<li>
<p><code>label</code></p>
<ul>
<li><strong>Purpose:</strong> Provides a label or identifier for the GPIO pin.</li>
<li><strong>Details:</strong> This is usually set by the kernel or device tree and identifies the pin by name. It's helpful for debugging or when managing multiple GPIO pins.</li>
</ul>
</li>
<li>
<p><code>power</code></p>
<ul>
<li><strong>Purpose:</strong> Provides power management controls for the GPIO pin.</li>
<li><strong>Details:</strong> This directory typically contains files related to the power state of the GPIO pin, such as runtime power management options. These controls might be more relevant in complex power-managed systems.</li>
</ul>
</li>
<li>
<p><code>subsystem</code></p>
<ul>
<li><strong>Purpose:</strong> A symbolic link to the subsystem the GPIO belongs to within sysfs.</li>
<li><strong>Details:</strong> This link typically points back to <code>/sys/class/gpio/</code>, indicating that this GPIO pin is part of the GPIO subsystem. It's part of the hierarchical organization in sysfs.</li>
</ul>
</li>
<li>
<p><code>uevent</code></p>
<ul>
<li><strong>Purpose:</strong> Provides information for udev, the device manager for the Linux kernel.</li>
<li><strong>Details:</strong> This file is used by udev to manage dynamic device nodes and trigger events when the state of the GPIO changes. It's generally used internally by the system for device management.</li>
</ul>
</li>
<li>
<p><code>value</code></p>
<ul>
<li><strong>Purpose:</strong> Reads or sets the current value of the GPIO pin.</li>
<li><strong>Values:</strong>
<ul>
<li><code>0</code>: Indicates a low state (0V) when reading, or sets the pin to a low state when writing.</li>
<li><code>1</code>: Indicates a high state (3.3V or 5V) when reading, or sets the pin to a high state when writing.</li>
</ul>
</li>
<li><strong>Usage:</strong> This is the primary file used to interact with the GPIO pin. Reading from it returns the current state of the pin, and writing to it sets the pin's output level if the pin is configured as an output.</li>
</ul>
</li>
</ol>
<h4 id="set-gpio-pin-27-as-an-output"><a class="header" href="#set-gpio-pin-27-as-an-output">Set GPIO Pin 27 as an Output</a></h4>
<p>This command sets the direction of GPIO pin 27 to output by writing out to the direction file.</p>
<pre><code class="language-bash">echo out &gt; direction
</code></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<blockquote>
<ul>
<li>
<p>The direction file controls whether the GPIO pin is configured as an input or an output.</p>
</li>
<li>
<p>Writing <code>out</code> to this file configures the pin as an output, meaning you can set the pin's value (high or low) to control external devices (e.g., turning an LED on or off).</p>
</li>
<li>
<p>Alternatively, writing in would configure the pin as an input, allowing the pin to read signals from external devices.</p>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="read-the-current-value-of-gpio-pin-27"><a class="header" href="#read-the-current-value-of-gpio-pin-27">Read the Current Value of GPIO Pin 27</a></h4>
<p>This command sets GPIO pin 27 to a high state (1) by writing 1 to the value file.</p>
<pre><code class="language-bash">$ echo 1 &gt; value
</code></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<blockquote>
<ul>
<li>
<p>The value file is used to control the state of a GPIO pin when it's configured as an output.</p>
</li>
<li>
<p>Writing <code>1</code> to this file sets the pin to a high state (e.g., 3.3V or 5V, depending on the board), which might turn on an LED or send a signal to another device.</p>
</li>
<li>
<p>Writing <code>0</code> would set the pin to a low state (0V), turning off the LED or signaling a low state to another device.</p>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="access-using-c-library"><a class="header" href="#access-using-c-library">Access using C library</a></h3>
<p>The <code>gpio.h</code> library will be developed further below.</p>
<pre><code class="language-c++">#include "gpio.h"
~~~
~~~
unsigned int pin = 14;
gpio_set_dir(pin,OUT);
gpio_set_value(pin,1);
</code></pre>
<h2 id="2-accessing-inaccessible-pins"><a class="header" href="#2-accessing-inaccessible-pins">2. Accessing Inaccessible Pins</a></h2>
<p>Before going into the details of configuring inaccessible pins, it is
necessary to briefly go over the inner workings of the BBB and touch
on concepts such as pin modes, the device tree and its overlays, and
how to interact with it.</p>
<h3 id="pin-modes"><a class="header" href="#pin-modes">Pin Modes</a></h3>
<p>As seen in the above graphics detailing the P8 and P9 headers, each
pin can be configured to one out of 8 possible modes. For our
purposes, it is important to note that mode7 is always the GPIO
configuration for every pin.</p>
<p>The pin mode for any given pin is stored in 7 bits using the following convention.</p>
<p><img src="./figures/GPIO_Bits.png" alt="GPIO_Bits" /></p>
<p>Notice the example configurations under the table. The bits values are
listed in Hexadecimal form, so that the two digits following "0x"
contain the values of all 7 bits. The last digit of the pair contains
the values of bits 0,1,2, and 3. As such, in order to be in mode7
(GPIO) bits 0,1, and 2 are all 1, giving a possible value of either 7
or F for the last hex digit. (Binary of either 0111 or 1111). The
first digit of the pair contains the values of bits 4,5, and 6 (with
the most significant bit being a constant 0). If the pin is configured
as an output, then the possible values of this bit are 0 and 1 (0000
and 0001) depending on if pull down or pull up is selected. If the pin
is an input, the possible values are 2 and 3 (0010 and 0011), again
depending on the pullup/down setting</p>
<p>The pin mode of each pin is configured in what is called a device tree
overlay, which will be discussed in detail in a later section.</p>
<h2 id="step-1-create-the-header-file-gpioh"><a class="header" href="#step-1-create-the-header-file-gpioh">Step 1: Create the Header File (<code>gpio.h</code>)</a></h2>
<ol>
<li>
<p>First, create a header file that declares the functions and defines necessary constants and enums.</p>
 <details>
 <summary>Code here...</summary>
<pre><code class="language-c">#ifndef GPIO_H
#define GPIO_H

#define SYSFS_GPIO_DIR "/sys/class/gpio"
#define POLL_TIMEOUT (3 * 1000) /* 3 seconds */
#define MAX_BUF 64

#define LED_DIR "/sys/class/leds/beaglebone:green:usr"

typedef enum {
    INPUT_PIN = 0,
    OUTPUT_PIN = 1
} PIN_DIRECTION;

typedef enum {
    LOW = 0,
    HIGH = 1
} PIN_VALUE;

typedef struct {
    char pin_name[6];
    unsigned int gpio_number;
} PinMap;

// Static array to map pin names to GPIO numbers
PinMap pin_map[] = {
    {"P8_31", 10}, {"P8_32", 11}, {"P9_31", 110}, {"P9_29", 111},
    {"P9_30", 112}, {"P9_28", 113}, {"P9_92", 114}, {"sysfs", 115},
    {"P9_91", 116}, {"P9_25", 117}, {"P9_20", 12}, {"P9_19", 13},
    {"P9_26", 14}, {"P9_24", 15}, {"A15", 19}, {"P9_22", 2},
    {"P9_41", 20}, {"P8_19", 22}, {"P8_13", 23}, {"P8_14", 26},
    {"P9_21", 3}, {"P9_11", 30}, {"P9_13", 31}, {"P8_25", 32},
    {"P8_24", 33}, {"P8_05", 34}, {"P8_06", 35}, {"P8_23", 36},
    {"P8_22", 37}, {"P8_03", 38}, {"P8_04", 39}, {"P9_18", 4},
    {"P8_12", 44}, {"P8_11", 45}, {"P8_16", 46}, {"P8_15", 47},
    {"P9_15", 48}, {"P9_23", 49}, {"P9_17", 5}, {"P9_14", 50},
    {"P9_16", 51}, {"P9_12", 60}, {"P8_26", 61}, {"P8_21", 62},
    {"P8_20", 63}, {"P8_18", 65}, {"P8_07", 66}, {"P8_08", 67},
    {"P8_10", 68}, {"P8_09", 69}, {"P9_42", 7}, {"P8_45", 70},
    {"P8_46", 71}, {"P8_43", 72}, {"P8_44", 73}, {"P8_41", 74},
    {"P8_42", 75}, {"P8_39", 76}, {"P8_40", 77}, {"P8_37", 78},
    {"P8_38", 79}, {"P8_35", 8}, {"P8_36", 80}, {"P8_34", 81},
    {"P8_27", 86}, {"P8_29", 87}, {"P8_28", 88}, {"P8_30", 89},
    {"P8_33", 9}, {"P8_27", 17}
};

// Function prototypes using pin names
int find_gpio_number(const char *pin_name);
int led_set_value(const char *pin_name, PIN_VALUE value);
int gpio_set_dir(const char *pin_name, PIN_DIRECTION out_flag);
int gpio_set_value(const char *pin_name, PIN_VALUE value);
int gpio_get_value(const char *pin_name, unsigned int *value);
int gpio_set_edge(const char *pin_name, const char *edge);
int gpio_fd_open(const char *pin_name);
int gpio_fd_close(int fd);

#endif /* GPIO_H */
</code></pre>
 </details>
</li>
</ol>
<h2 id="step-3-create-the-implementation-file-gpioc"><a class="header" href="#step-3-create-the-implementation-file-gpioc">Step 3: Create the Implementation File (gpio.c)</a></h2>
<ol start="2">
<li>
<p>Next, create the <code>gpio.c</code> file that implements the functions declared in <code>gpio.h</code>.</p>
 <details>
 <summary>Code here... </summary>
<pre><code class="language-c">#include "gpio.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;poll.h&gt;


// Function to find GPIO number from pin name
int find_gpio_number(const char *pin_name) {
    for (int i = 0; i &lt; sizeof(pin_map) / sizeof(PinMap); i++) {
        if (strcmp(pin_map[i].pin_name, pin_name) == 0) {
            return pin_map[i].gpio_number;
        }
    }
    return -1;  // Return -1 if the pin is not found
}

// GPIO functions using pin names directly

int led_set_value(const char *pin_name, PIN_VALUE value) {
    unsigned int gpio = find_gpio_number(pin_name);
    if (gpio == -1) {
        fprintf(stderr, "Invalid pin name: %s\n", pin_name);
        return -1;
    }

    char buf[MAX_BUF];
    snprintf(buf, sizeof(buf), LED_DIR "%d/brightness", gpio);

    int fd = open(buf, O_WRONLY);
    if (fd &lt; 0) {
        perror("led/set-value");
        return fd;
    }

    if (value == LOW) {
        write(fd, "0", 2);
    } else {
        write(fd, "1", 2);
    }

    close(fd);
    return 0;
}

int gpio_set_dir(const char *pin_name, PIN_DIRECTION out_flag) {
    unsigned int gpio = find_gpio_number(pin_name);
    if (gpio == -1) {
        fprintf(stderr, "Invalid pin name: %s\n", pin_name);
        return -1;
    }

    char buf[MAX_BUF];
    snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR "/gpio%d/direction", gpio);

    int fd = open(buf, O_WRONLY);
    if (fd &lt; 0) {
        perror("gpio/direction");
        return fd;
    }

    if (out_flag == OUTPUT_PIN) {
        write(fd, "out", 4);
    } else {
        write(fd, "in", 3);
    }

    close(fd);
    return 0;
}

int gpio_set_value(const char *pin_name, PIN_VALUE value) {
    unsigned int gpio = find_gpio_number(pin_name);
    if (gpio == -1) {
        fprintf(stderr, "Invalid pin name: %s\n", pin_name);
        return -1;
    }

    char buf[MAX_BUF];
    snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR "/gpio%d/value", gpio);

    int fd = open(buf, O_WRONLY);
    if (fd &lt; 0) {
        perror("gpio/set-value");
        return fd;
    }

    if (value == LOW) {
        write(fd, "0", 2);
    } else {
        write(fd, "1", 2);
    }

    close(fd);
    return 0;
}

int gpio_get_value(const char *pin_name, unsigned int *value) {
    unsigned int gpio = find_gpio_number(pin_name);
    if (gpio == -1) {
        fprintf(stderr, "Invalid pin name: %s\n", pin_name);
        return -1;
    }

    char buf[MAX_BUF];
    snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR "/gpio%d/value", gpio);

    int fd = open(buf, O_RDONLY);
    if (fd &lt; 0) {
        perror("gpio/get-value");
        return fd;
    }

    char ch;
    read(fd, &amp;ch, 1);

    *value = (ch != '0') ? 1 : 0;

    close(fd);
    return 0;
}

int gpio_set_edge(const char *pin_name, const char *edge) {
    unsigned int gpio = find_gpio_number(pin_name);
    if (gpio == -1) {
        fprintf(stderr, "Invalid pin name: %s\n", pin_name);
        return -1;
    }

    char buf[MAX_BUF];
    snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR "/gpio%d/edge", gpio);

    int fd = open(buf, O_WRONLY);
    if (fd &lt; 0) {
        perror("gpio/set-edge");
        return fd;
    }

    write(fd, edge, strlen(edge) + 1);
    close(fd);
    return 0;
}

int gpio_fd_open(const char *pin_name) {
    unsigned int gpio = find_gpio_number(pin_name);
    if (gpio == -1) {
        fprintf(stderr, "Invalid pin name: %s\n", pin_name);
        return -1;
    }

    char buf[MAX_BUF];
    snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR "/gpio%d/value", gpio);

    int fd = open(buf, O_RDONLY | O_NONBLOCK);
    if (fd &lt; 0) {
        perror("gpio/fd_open");
    }
    return fd;
}

int gpio_fd_close(int fd) {
    return close(fd);
}
</code></pre>
</li>
</ol>
<h2 id="step-4-compile-the-object-file-and-create-libraries"><a class="header" href="#step-4-compile-the-object-file-and-create-libraries">Step 4: Compile the Object File and Create Libraries</a></h2>
<ol start="3">
<li>
<p>Compile gpio.c into an Object File by Using the following command to compile <code>gpio.c</code> into an object file (<code>gpio.o</code>):</p>
<pre><code class="language-sh">$ gcc -c gpio.c -o gpio.o
</code></pre>
</li>
<li>
<p>Create a Static Library (<code>libgpio.a</code>) to create a static library, use the <code>ar</code> command:</p>
<pre><code class="language-sh">$ ar rcs libgpio.a gpio.o
</code></pre>
<ul>
<li><strong>Command Breakdown:</strong>
<ul>
<li><code>ar</code>: The archiver tool used to create and maintain library archives.</li>
<li><code>rcs</code>: Flags where r inserts the files into the archive, c creates the archive if it doesn't exist, and s creates an index for quick symbol lookup.</li>
<li><code>libgpio.a</code>: The name of the static library being created.</li>
<li><code>gpio.o</code>: The object file to be included in the library.</li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<p><strong>Explanation: What is a Static Library?</strong></p>
<p>A static library is a collection of object files that are linked into the final executable at compile time. Once linked, the code from the static library becomes part of the executable binary. This means that the executable will carry a copy of the library's code, making it self-contained and independent of the library file after compilation.</p>
</blockquote>
</blockquote>
</li>
<li>
<p>Create a Shared Library (<code>libgpio.so</code>) to create a shared library, use the following <code>gcc</code> command:</p>
<pre><code class="language-sh">$ gcc -shared -o libgpio.so gpio.o
</code></pre>
<ul>
<li><strong>Command Breakdown:</strong>
<ul>
<li><code>-shared</code>: Tells gcc to produce a shared library.</li>
<li><code>-o libgpio.so</code>: Specifies the output filename for the shared library.</li>
<li><code>gpio.o</code>: The object file to be included in the library.</li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<p><strong>Explanation: What is a Shared Library?</strong></p>
<p>A shared library, on the other hand, is not linked into the final executable at compile time. Instead, it is loaded into memory at runtime. Multiple programs can share a single copy of a shared library, which can save memory and allow updates to the library without recompiling the programs that use it.</p>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="step-5-install-the-header-and-library-files-system-wide"><a class="header" href="#step-5-install-the-header-and-library-files-system-wide">Step 5: Install the Header and Library Files System-Wide</a></h2>
<ol start="6">
<li>
<p>You could manually copy the header file to <code>/usr/include</code> and the libraries to <code>/usr/lib</code>, or skip to the next section and create a <code>Makefile</code> to do it for you each time.</p>
<pre><code class="language-sh">$ sudo cp gpio.h /usr/include/
$ sudo cp libgpio.a /usr/lib/
$ sudo cp libgpio.so /usr/lib/
$ sudo ldconfig  # Update the shared library cache
</code></pre>
</li>
</ol>
<h2 id="step-5-automate-with-a-makefile"><a class="header" href="#step-5-automate-with-a-makefile">Step 5: Automate with a Makefile</a></h2>
<ol start="7">
<li>
<p>Instead of running these commands manually, you can automate the build process using a Makefile.</p>
 <details>
 <summary>Code here... </summary>
<pre><code class="language-makefile"># Variables
CC = gcc
CFLAGS = -Wall -Werror -fPIC  # -fPIC is needed for shared libraries
AR = ar
ARFLAGS = rcs
TARGET_STATIC = libgpio.a
TARGET_SHARED = libgpio.so
OBJ = gpio.o

# Default target: Build both libraries
all: $(TARGET_STATIC) $(TARGET_SHARED)

# Compile the gpio.c into an object file
$(OBJ): gpio.c
    $(CC) $(CFLAGS) -c gpio.c -o $(OBJ)

# Create the static library
$(TARGET_STATIC): $(OBJ)
    $(AR) $(ARFLAGS) $(TARGET_STATIC) $(OBJ)

# Create the shared library
$(TARGET_SHARED): $(OBJ)
    $(CC) -shared -o $(TARGET_SHARED) $(OBJ)

# Clean up build artifacts
clean:
    rm -f $(OBJ) $(TARGET_STATIC) $(TARGET_SHARED)

# Install libraries and header
install: $(TARGET_STATIC) $(TARGET_SHARED)
    sudo cp gpio.h /usr/include/
    sudo cp $(TARGET_STATIC) /usr/lib/
    sudo cp $(TARGET_SHARED) /usr/lib/
    sudo ldconfig

# Uninstall libraries and header
uninstall:
    sudo rm -f /usr/include/gpio.h
    sudo rm -f /usr/lib/$(TARGET_STATIC)
    sudo rm -f /usr/lib/$(TARGET_SHARED)
    sudo ldconfig

# Phony targets
.PHONY: all clean install uninstall
</code></pre>
 </details>
</li>
<li>
<p>As long as the Makefile is within directory with the custom gpio c files you can use the <code>make</code> command:</p>
<ul>
<li>
<p>Remove <code>gpio.h</code>, and static and share libraries from the respective directories</p>
<pre><code class="language-sh">$ make uninstall
</code></pre>
</li>
<li>
<p>To clean up the build artefacts run:</p>
<pre><code class="language-sh">$ make clean
</code></pre>
</li>
<li>
<p>To build the libraries and object files:</p>
<pre><code class="language-sh">$ make all
</code></pre>
</li>
<li>
<p>Lastly, use the install command to cp libraries and header to respective root directories:</p>
<pre><code class="language-sh">$ make install
&gt; gcc -Wall -Werror -fPIC   -c gpio.c -o gpio.o
  ar rcs libgpio.a gpio.o
  gcc -shared -o libgpio.so gpio.o
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="step-6-using-the-our-new-libary-to-control-a-pin"><a class="header" href="#step-6-using-the-our-new-libary-to-control-a-pin">Step 6: Using the our new libary to control a pin</a></h2>
<ol start="9">
<li>
<p>Change directory and <code>../</code> and make a new directory called <code>blink</code> and navigate into it.</p>
<pre><code class="language-sh">$ cd ../
$ mkdir blink
$ cd blink
</code></pre>
</li>
<li>
<p>Create a new .c file called... <code>blink.c</code> and chose your preferred editor to open it.</p>
<pre><code class="language-sh">$ touch blink.c
$ vim blink.c
</code></pre>
</li>
<li>
<p>Now we are going to set up the program to use our system wide library and header with <code>gpio.h</code>:</p>
<details>
<summary>Code here... </summary>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include "gpio.h"

int main() {
    const char *pin_name = "P9_30";  // Use the pin name directly

    // Set the GPIO direction to output
    gpio_set_dir(pin_name, OUTPUT_PIN);

    while(1){
        // Set the GPIO pin value to HIGH (turn on the LED)
        gpio_set_value(pin_name, HIGH);
        printf("LED on %s is ON\n", pin_name);

        // Wait for a few seconds
        sleep(3);

        // Set the GPIO pin value to LOW (turn off the LED)
        gpio_set_value(pin_name, LOW);
        printf("LED on %s is OFF\n", pin_name);
        sleep(3);
    }
    return 0;
}
</code></pre>
</details>
</li>
<li>
<p>We can use this oneliner to compile the code:</p>
<pre><code class="language-sh">$ gcc gpio.c -lgpio -o blink 
</code></pre>
</li>
<li>
<p>Alternatively we can use a <code>Makefile</code> like before:</p>
<details>
<summary>Code here... </summary>
<pre><code class="language-makefile"># Compiler and flags
CC = gcc
CFLAGS = -Wall -Werror

# Target executable name
TARGET = blink

# Source files
SRC = blink.c

# Library to link against
LIBS = -lgpio

# Default target: build the executable
all: $(TARGET)

# Build the executable
$(TARGET): $(SRC)
        $(CC) $(CFLAGS) $(SRC) $(LIBS) -o $(TARGET)

# Clean up build artifacts
clean:
        rm -f $(TARGET)

# Phony targets to avoid conflicts with files of the same name
.PHONY: all clean
</code></pre>
<p>Invoke make to build the executable:</p>
<pre><code class="language-sh">$ make
</code></pre>
</details>
</li>
<li>
<p>Use the led and etc to wire up and run the code:</p>
<pre><code class="language-sh">$ ./blink
</code></pre>
<ul>
<li>If all is well, and you have connected up your led to the correct pin, the light should turn on and then off.</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../PinExploration/PinExploration.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../ADCLibrary/ADCLibrary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../PinExploration/PinExploration.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../ADCLibrary/ADCLibrary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
